#summary 如何控制战场时间节拍和指令顺序
#labels Phase-QA,Phase-Support

<wiki:toc>

= 问题根源 =
昨天Max 提出了一个非常有意思的问题 （针对branches/eb0-1.0 标签的代码），如何控制战场时序。
Max做了个实验。 他把clock 的延时提高到了 5000 毫秒，同时修改了feardFarmer 的消息发送程序。 运行代码：

{{{
Time: 3 s ....
"Blue Side: dont kill us, we are poor farmers" 
"Red Side: marching forword" 
"Blue Side: dont kill us, we are poor farmers" 
"Blue Side: dont kill us, we are poor farmers" 
"Red Side: marching forword" 
"Blue Side: dont kill us, we are poor farmers" 
"Blue Side: dont kill us, we are poor farmers" 
Time: 4 s ....
}}}

大家可以看到， BlueSide 在一个时间节拍中发出了5个消息。 而Red Side 发出了 2 个消息。 这是否会带来不公平呢？  另外我们的时钟程序是否完全在战斗中没有用呢？ 

现在的代码是未完成的中间阶段。 现在确实看起来是这样的。战场程序一个非常重要的功能就是要控制好来自双方的时序。下一步的工作就是要编写对于消息的处理机制。 解决Max提出的疑问，也就是编写命令消息处理程序的算法。 

== 算法 ==

http://erlbattle.googlecode.com/files/theWorld.png  

结构图中上方有两个 none-named protected ets 表。 这两表是双方私有的指令队列。 也就是下一步动作。 

当我们主程序收到决策程序发来的指令后，其实我们并不真的去执行那个动作，而是将其放到队列中。 每个战士的队列长度只有 1， 也就是说如果一个指令发过来进入队列后，没有及时被战场程序取走，又发来一个指令的话，后面的指令冲掉前面的指令。 

然后正好clock 发出的时间节拍指令来的时候， 对于时间消息的处理程序才是真正执行指令的代码入口。这个程序做几个动作：

1。首先去找战场状态表，将其中所有动作生效时间是当前的战士该移动的移动，该攻击的攻击。 这些战士完成了他的动作后，状态处于wait 了。 这代表这个战士已经准备好做下一个动作了。 而比如在20秒的时候发动一个向后退的动作，他的生效时间是 24秒。 在 20秒，21，22，23 秒的时候他都不能接受其他指令， 必须等到后退动作到 24秒完成后才能开始下一个动作。 

2. 将战场状态表中所有处于wait 状态的战士全部去上述的指令队列中找，看看决策程序规划的该战士下一个动作是什么。 大家注意，在接口规范文档中，提出的命令指令格式是：

        {command , 指令, 发起的战士，发动时间} 

   第四个参数“发动时间” 如果这个发动时间小于等于当前时间，这个动作就会被执行，主程序更新战场状态表中的战士动作，和预计发动时间字段。 如果决策程序希望一个动作立刻执行可以把 发动时间设为 0 。 这个0 永远小于当前时间因此你的动作永远会被立刻执行。 

为什么说只查那些wait 状态的战士呢？  因为当你的刀挥出去后，还是要等刀落下，才能做另一个动作。或者你开始往后跨一步退的时候，要等这个脚落地，站稳，完成退的动作才能做下一个动作。 


系统就是这样来控制节拍的。 


== Discuss ==


