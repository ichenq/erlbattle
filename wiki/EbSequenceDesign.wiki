#summary 如何控制战场时间节拍和指令顺序
#labels Phase-QA,Phase-Support



== 整体结构图 ==

http://erlbattle.googlecode.com/files/theWorld.png  

图中浅蓝色的进程是eb 核心系统； 两个椭圆的进程是玩家开发的指挥进程。 浅黄色折角的是4个ets 表，用于在进程间传递信息； 


== 进程说明 ==

1. 战场进程 erlbattle
 这个是系统的核心进程，负责在时间节拍到达时，首先运算世界中各个战士动作（移动，转身，攻击），并将死去的战士挪出战场； 然后对于处于wait 状态的战士到redQueue, blueQueue 取下一步指令; 取完消息后，向消息队列进程发送清除指令的消息； 本进程负责维护战场状态表（battle_field）；

2. 时钟进程 worldclock
 专门负责维护世界的节拍。每个节拍延迟时间考虑采用测速方案，确保在不同速度的机器上，给予玩家指挥进程相同的CPU 处理指令次数。 worldclock 负责定期向主程序发出时钟节拍信号。 同时维护一个时钟表（battle_timer）

3. 红/蓝方消息队列进程 redChannel, blueChannel 
 负责接收来自玩家指挥进程的消息；然后维护各自维护自己的消息队列； 每个战士只有一个指令被缓存；老的如果没有被执行，就会被新的消息冲掉。 如果接受到战场进程发来的清除指令消息，就将已经被处理的消息清除

4. 玩家指挥进程
 由玩家编写的人工智能程序。 能够根据战场情况灵活指挥自己的队伍，攻击敌人，并取得胜利


== 共享ETS 表说明 ==



结构图中上方有两个 none-named protected ets 表。 这两表是双方私有的指令队列。 也就是下一步动作。 

当我们主程序收到决策程序发来的指令后，其实我们并不真的去执行那个动作，而是将其放到队列中。 每个战士的队列长度只有 1， 也就是说如果一个指令发过来进入队列后，没有及时被战场程序取走，又发来一个指令的话，后面的指令冲掉前面的指令。 

然后正好clock 发出的时间节拍指令来的时候， 对于时间消息的处理程序才是真正执行指令的代码入口。这个程序做几个动作：

1。首先去找战场状态表，将其中所有动作生效时间是当前的战士该移动的移动，该攻击的攻击。 这些战士完成了他的动作后，状态处于wait 了。 这代表这个战士已经准备好做下一个动作了。 而比如在20秒的时候发动一个向后退的动作，他的生效时间是 24秒。 在 20秒，21，22，23 秒的时候他都不能接受其他指令， 必须等到后退动作到 24秒完成后才能开始下一个动作。 

2. 将战场状态表中所有处于wait 状态的战士全部去上述的指令队列中找，看看决策程序规划的该战士下一个动作是什么。 大家注意，在接口规范文档中，提出的命令指令格式是：

        {command , 指令, 发起的战士，发动时间} 

   第四个参数“发动时间” 如果这个发动时间小于等于当前时间，这个动作就会被执行，主程序更新战场状态表中的战士动作，和预计发动时间字段。 如果决策程序希望一个动作立刻执行可以把 发动时间设为 0 。 这个0 永远小于当前时间因此你的动作永远会被立刻执行。 

为什么说只查那些wait 状态的战士呢？  因为当你的刀挥出去后，还是要等刀落下，才能做另一个动作。或者你开始往后跨一步退的时候，要等这个脚落地，站稳，完成退的动作才能做下一个动作。 


系统就是这样来控制节拍的。 

3. 动作生效时间

    * 向前移动一格：2秒
    * 转方向：1 秒
    * 向后退一格： 4秒
    * 发动一次攻击：2秒 

    当前时间是26的话，如果发出指令的话，真正生效的节拍是 26 + t. 也就是说移动发生在28. 转向发生在27， 后退发生在30，攻击发生在 28


== Discuss ==