#summary 指挥程序和战场主程序之间的接口规范

1.消息传递机制

  主程序在spawn 指挥程序：
           spawn(feardFarmers, start, [self(), "Blue"])
  传入了self() 和 属于哪一方的消息

2.战场状态

  使用命名的 ETS 表： BattleField; 
  结构：
         
    * 战士编号 1 - 10   (死亡后，从表中删除）
    * 位置 （x, y）   
    * 血量  1 - 100
    * 面朝的方向  （N, S, W, E）  ---北南西东---或者说上下左右
    * 当前动作 (无动作 wait,  前进 forward, 后退 back, 转向左边 turnLeft,转向右边 turnRight, 转向后面 turnBack, 攻击 attack)
    * 当前动作生效时间
    * 行动次序 

其中：
    位置按照坐标第一向限的方式描述。 左下为 0，0 ，  右上为 （14，14）
    考虑到未来图形化显示的问题，部队为左右进攻。 
    因此左边部队（蓝）为：0，3 - 0，12
        右边部队（红）为：14，3 - 14，12

3. 战场时间钟
    
    一个就一个字段的命名的 protected ETS 表 （Clock)
    * 当前时间

4. 命令消息

    {command , 指令, 发起的战士，发动时间}

其中指令为：    前进 forward, 后退 back, 转向左边 turnLeft,转向右边 turnRight, 转向后面 turnBack, 攻击 attack, 原地待命 wait 

发动时间：指希望该动作在哪个时间点发动。 比如我们希望部队在统一时间向前前进一步。而不希望他们乱走。  发动时间如果是 0  则表示希望立刻发动该动作。


5. 战场主程序对于命令队列的管理

主程序使用两个ETS 管理各自的指令队列。 每个战士同时只有一个指令队列，如果这个指令没有执行，新的指令进来的话，就会冲掉老的指令。

战场每个节拍先把在BattleField 表中体现的当前动作能够完成的先完成（比如攻击需要两个节拍，如果上一个刚刚发起的攻击，这个节拍不会完成，就要等待该动作完成后才接受新的任务指令）。 然后对处于没有任务状态的战士到队列中找下一个指令。此时有三种可能，
  a. 没有指令：  战士不动
  b. 有指令，该指令的生效时间小于等于当前时间，或者等于0 ； 此时就会安排战士执行这个动作。 
  c. 有指令，但该指令的生效时间大于当前时间； 此时战士仍然不动
对于b 情况，将指令放到状态表中（表明动作开始发生了），根据每个动作的开销， 计算预计产生效果的时间。 



     